<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MongoDB C++ Driver: mongo::ReplicaSetMonitor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MongoDB C++ Driver<span id="projectnumber">&#160;legacy-0.8.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemongo.html">mongo</a></li><li class="navelem"><a class="el" href="classmongo_1_1ReplicaSetMonitor.html">ReplicaSetMonitor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classmongo_1_1ReplicaSetMonitor-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">mongo::ReplicaSetMonitor Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Holds state about a replica set and provides a means to refresh the local view.  
 <a href="classmongo_1_1ReplicaSetMonitor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="replica__set__monitor_8h_source.html">replica_set_monitor.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for mongo::ReplicaSetMonitor:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classmongo_1_1ReplicaSetMonitor.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmongo_1_1ReplicaSetMonitor_1_1IsMasterReply.html">IsMasterReply</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmongo_1_1ReplicaSetMonitor_1_1NextStep.html">NextStep</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmongo_1_1ReplicaSetMonitor_1_1ScanState.html">ScanState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmongo_1_1ReplicaSetMonitor_1_1SetState.html">SetState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa31cc064ed6f97cca5190304bfb47812"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1ReplicaSetMonitor.html#aa31cc064ed6f97cca5190304bfb47812">ReplicaSetMonitor</a> (StringData name, const std::set&lt; <a class="el" href="structmongo_1_1HostAndPort.html">HostAndPort</a> &gt; &amp;seeds)</td></tr>
<tr class="memdesc:aa31cc064ed6f97cca5190304bfb47812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes local state.  <br /></td></tr>
<tr class="separator:aa31cc064ed6f97cca5190304bfb47812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b9158339c4762dda3303c0f1d21d42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmongo_1_1HostAndPort.html">HostAndPort</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1ReplicaSetMonitor.html#a62b9158339c4762dda3303c0f1d21d42">getHostOrRefresh</a> (const <a class="el" href="structmongo_1_1ReadPreferenceSetting.html">ReadPreferenceSetting</a> &amp;criteria)</td></tr>
<tr class="memdesc:a62b9158339c4762dda3303c0f1d21d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a host matching criteria or an empty <a class="el" href="structmongo_1_1HostAndPort.html" title="helper for manipulating host:port connection endpoints.">HostAndPort</a> if no host matches.  <br /></td></tr>
<tr class="separator:a62b9158339c4762dda3303c0f1d21d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc78b4c336cec685a4ca13e00ba0337b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmongo_1_1HostAndPort.html">HostAndPort</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1ReplicaSetMonitor.html#acc78b4c336cec685a4ca13e00ba0337b">getMasterOrUassert</a> ()</td></tr>
<tr class="memdesc:acc78b4c336cec685a4ca13e00ba0337b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the host we think is the current master or uasserts.  <br /></td></tr>
<tr class="separator:acc78b4c336cec685a4ca13e00ba0337b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b9142e147364322c0868022182777b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmongo_1_1ReplicaSetMonitor.html#a84e83e848d3b109ca37d294c5cac0856">Refresher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1ReplicaSetMonitor.html#a61b9142e147364322c0868022182777b">startOrContinueRefresh</a> ()</td></tr>
<tr class="memdesc:a61b9142e147364322c0868022182777b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a refresher object that can be used to update our view of the set.  <br /></td></tr>
<tr class="separator:a61b9142e147364322c0868022182777b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07049d6895d074584d0e653fb4614a50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1ReplicaSetMonitor.html#a07049d6895d074584d0e653fb4614a50">failedHost</a> (const <a class="el" href="structmongo_1_1HostAndPort.html">HostAndPort</a> &amp;host)</td></tr>
<tr class="memdesc:a07049d6895d074584d0e653fb4614a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies this Monitor that a host has failed and should be considered down.  <br /></td></tr>
<tr class="separator:a07049d6895d074584d0e653fb4614a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4616bbd03ab8cd6b9e38f43cbb80a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1ReplicaSetMonitor.html#a0f4616bbd03ab8cd6b9e38f43cbb80a3">isPrimary</a> (const <a class="el" href="structmongo_1_1HostAndPort.html">HostAndPort</a> &amp;host) const</td></tr>
<tr class="memdesc:a0f4616bbd03ab8cd6b9e38f43cbb80a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this node is the master based ONLY on local data.  <br /></td></tr>
<tr class="separator:a0f4616bbd03ab8cd6b9e38f43cbb80a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2037e31161aaa3494c475d9a0782e6"><td class="memItemLeft" align="right" valign="top"><a id="a6b2037e31161aaa3494c475d9a0782e6" name="a6b2037e31161aaa3494c475d9a0782e6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isHostUp</b> (const <a class="el" href="structmongo_1_1HostAndPort.html">HostAndPort</a> &amp;host) const</td></tr>
<tr class="memdesc:a6b2037e31161aaa3494c475d9a0782e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if host is part of this set and is considered up (meaning it can accept queries). <br /></td></tr>
<tr class="separator:a6b2037e31161aaa3494c475d9a0782e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5c12e92cabc441a0049db707087a1d"><td class="memItemLeft" align="right" valign="top"><a id="a5e5c12e92cabc441a0049db707087a1d" name="a5e5c12e92cabc441a0049db707087a1d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getConsecutiveFailedScans</b> () const</td></tr>
<tr class="memdesc:a5e5c12e92cabc441a0049db707087a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">How may times in a row have we tried to refresh without successfully contacting any hosts who claim to be members of this set? <br /></td></tr>
<tr class="separator:a5e5c12e92cabc441a0049db707087a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322f78e11d6c9a08d15970c12b9755ae"><td class="memItemLeft" align="right" valign="top"><a id="a322f78e11d6c9a08d15970c12b9755ae" name="a322f78e11d6c9a08d15970c12b9755ae"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getName</b> () const</td></tr>
<tr class="memdesc:a322f78e11d6c9a08d15970c12b9755ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the set. <br /></td></tr>
<tr class="separator:a322f78e11d6c9a08d15970c12b9755ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad197683d25912ea06d6d2e9363e7b74a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1ReplicaSetMonitor.html#ad197683d25912ea06d6d2e9363e7b74a">getServerAddress</a> () const</td></tr>
<tr class="memdesc:ad197683d25912ea06d6d2e9363e7b74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string with the format name/server1,server2.  <br /></td></tr>
<tr class="separator:ad197683d25912ea06d6d2e9363e7b74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a91e681ab7df8233c37f9daa5bb153"><td class="memItemLeft" align="right" valign="top"><a id="a46a91e681ab7df8233c37f9daa5bb153" name="a46a91e681ab7df8233c37f9daa5bb153"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>contains</b> (const <a class="el" href="structmongo_1_1HostAndPort.html">HostAndPort</a> &amp;server) const</td></tr>
<tr class="memdesc:a46a91e681ab7df8233c37f9daa5bb153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is server part of this set? Uses only cached information. <br /></td></tr>
<tr class="separator:a46a91e681ab7df8233c37f9daa5bb153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532fd38581e6c5685827efe75495227c"><td class="memItemLeft" align="right" valign="top"><a id="a532fd38581e6c5685827efe75495227c" name="a532fd38581e6c5685827efe75495227c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>appendInfo</b> (<a class="el" href="classmongo_1_1BSONObjBuilder.html">BSONObjBuilder</a> &amp;b) const</td></tr>
<tr class="memdesc:a532fd38581e6c5685827efe75495227c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes information about our cached view of the set to a <a class="el" href="classmongo_1_1BSONObjBuilder.html" title="Utility for creating a BSONObj.">BSONObjBuilder</a>. <br /></td></tr>
<tr class="separator:a532fd38581e6c5685827efe75495227c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6fe3d573f781d6bfcaf2e048eea024"><td class="memItemLeft" align="right" valign="top"><a id="a1c6fe3d573f781d6bfcaf2e048eea024" name="a1c6fe3d573f781d6bfcaf2e048eea024"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ReplicaSetMonitor</b> (const SetStatePtr &amp;initialState)</td></tr>
<tr class="memdesc:a1c6fe3d573f781d6bfcaf2e048eea024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows tests to set initial conditions and introspect the current state. <br /></td></tr>
<tr class="separator:a1c6fe3d573f781d6bfcaf2e048eea024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac242e9150b7e611600486cd30ed954e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmongo_1_1HostAndPort.html">HostAndPort</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1ReplicaSetMonitor.html#ac242e9150b7e611600486cd30ed954e2">refreshUntilMatches</a> (const <a class="el" href="structmongo_1_1ReadPreferenceSetting.html">ReadPreferenceSetting</a> &amp;criteria)</td></tr>
<tr class="memdesc:ac242e9150b7e611600486cd30ed954e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contact hosts in the set to refresh our view, but stop once a host matches criteria.  <br /></td></tr>
<tr class="separator:ac242e9150b7e611600486cd30ed954e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48f698ac7a18221fb5515017646e42f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1ReplicaSetMonitor.html#ac48f698ac7a18221fb5515017646e42f">refreshAll</a> ()</td></tr>
<tr class="memdesc:ac48f698ac7a18221fb5515017646e42f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refresh all hosts.  <br /></td></tr>
<tr class="separator:ac48f698ac7a18221fb5515017646e42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e83e848d3b109ca37d294c5cac0856"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1ReplicaSetMonitor.html#a84e83e848d3b109ca37d294c5cac0856">Refresher</a> (const SetStatePtr &amp;setState)</td></tr>
<tr class="memdesc:a84e83e848d3b109ca37d294c5cac0856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any passed-in pointers are shared with caller.  <br /></td></tr>
<tr class="separator:a84e83e848d3b109ca37d294c5cac0856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422b4b9f08eea0abdfb24dc41d7d9a15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmongo_1_1ReplicaSetMonitor_1_1NextStep.html">NextStep</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1ReplicaSetMonitor.html#a422b4b9f08eea0abdfb24dc41d7d9a15">getNextStep</a> ()</td></tr>
<tr class="memdesc:a422b4b9f08eea0abdfb24dc41d7d9a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next step to take.  <br /></td></tr>
<tr class="separator:a422b4b9f08eea0abdfb24dc41d7d9a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa366c8e68287f832beac97003900944a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1ReplicaSetMonitor.html#aa366c8e68287f832beac97003900944a">receivedIsMaster</a> (const <a class="el" href="structmongo_1_1HostAndPort.html">HostAndPort</a> &amp;from, int64_t latencyMicros, const <a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> &amp;reply)</td></tr>
<tr class="memdesc:aa366c8e68287f832beac97003900944a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this if a host returned from getNextStep successfully replied to an isMaster call.  <br /></td></tr>
<tr class="separator:aa366c8e68287f832beac97003900944a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07049d6895d074584d0e653fb4614a50"><td class="memItemLeft" align="right" valign="top"><a id="a07049d6895d074584d0e653fb4614a50" name="a07049d6895d074584d0e653fb4614a50"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>failedHost</b> (const <a class="el" href="structmongo_1_1HostAndPort.html">HostAndPort</a> &amp;host)</td></tr>
<tr class="memdesc:a07049d6895d074584d0e653fb4614a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this if a host returned from getNextStep failed to reply to an isMaster call. <br /></td></tr>
<tr class="separator:a07049d6895d074584d0e653fb4614a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd166ac82c50e776eab02f1061af754"><td class="memItemLeft" align="right" valign="top"><a id="a6cd166ac82c50e776eab02f1061af754" name="a6cd166ac82c50e776eab02f1061af754"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>startedNewScan</b> () const</td></tr>
<tr class="memdesc:a6cd166ac82c50e776eab02f1061af754"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this Refresher started a new full scan rather than joining an existing one. <br /></td></tr>
<tr class="separator:a6cd166ac82c50e776eab02f1061af754"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa13c5703ea0b0a3124c589fa11fca9aa"><td class="memItemLeft" align="right" valign="top"><a id="aa13c5703ea0b0a3124c589fa11fca9aa" name="aa13c5703ea0b0a3124c589fa11fca9aa"></a>
static void MONGO_CLIENT_FUNC&#160;</td><td class="memItemRight" valign="bottom"><b>createIfNeeded</b> (const std::string &amp;name, const std::set&lt; <a class="el" href="structmongo_1_1HostAndPort.html">HostAndPort</a> &gt; &amp;servers)</td></tr>
<tr class="memdesc:aa13c5703ea0b0a3124c589fa11fca9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classmongo_1_1ReplicaSetMonitor.html" title="Holds state about a replica set and provides a means to refresh the local view.">ReplicaSetMonitor</a>, if it doesn't already exist. <br /></td></tr>
<tr class="separator:aa13c5703ea0b0a3124c589fa11fca9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a3b0cc91d7566b477a1e21a27c1b68"><td class="memItemLeft" align="right" valign="top">static ReplicaSetMonitorPtr MONGO_CLIENT_FUNC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1ReplicaSetMonitor.html#a61a3b0cc91d7566b477a1e21a27c1b68">get</a> (const std::string &amp;name, bool createFromSeed=false)</td></tr>
<tr class="memdesc:a61a3b0cc91d7566b477a1e21a27c1b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets a cached Monitor per name.  <br /></td></tr>
<tr class="separator:a61a3b0cc91d7566b477a1e21a27c1b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1787a1f7ff1c8ac3ac1258d02394362"><td class="memItemLeft" align="right" valign="top"><a id="ac1787a1f7ff1c8ac3ac1258d02394362" name="ac1787a1f7ff1c8ac3ac1258d02394362"></a>
static std::set&lt; std::string &gt; MONGO_CLIENT_FUNC&#160;</td><td class="memItemRight" valign="bottom"><b>getAllTrackedSets</b> ()</td></tr>
<tr class="memdesc:ac1787a1f7ff1c8ac3ac1258d02394362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all the currently tracked replica set names. <br /></td></tr>
<tr class="separator:ac1787a1f7ff1c8ac3ac1258d02394362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038df358175462298aede902eb26f31f"><td class="memItemLeft" align="right" valign="top">static void MONGO_CLIENT_FUNC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1ReplicaSetMonitor.html#a038df358175462298aede902eb26f31f">remove</a> (const std::string &amp;name, bool clearSeedCache=false)</td></tr>
<tr class="memdesc:a038df358175462298aede902eb26f31f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the <a class="el" href="classmongo_1_1ReplicaSetMonitor.html" title="Holds state about a replica set and provides a means to refresh the local view.">ReplicaSetMonitor</a> for the given set name from _sets, which will delete it.  <br /></td></tr>
<tr class="separator:a038df358175462298aede902eb26f31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6626a0a68f5461d46c8a85f60061a1b"><td class="memItemLeft" align="right" valign="top">static void MONGO_CLIENT_FUNC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1ReplicaSetMonitor.html#ae6626a0a68f5461d46c8a85f60061a1b">setConfigChangeHook</a> (ConfigChangeHook hook)</td></tr>
<tr class="memdesc:ae6626a0a68f5461d46c8a85f60061a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the hook to be called whenever the config of any replica set changes.  <br /></td></tr>
<tr class="separator:ae6626a0a68f5461d46c8a85f60061a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f81fd43d3db2bfa54d66d06df294e6"><td class="memItemLeft" align="right" valign="top">static void MONGO_CLIENT_FUNC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1ReplicaSetMonitor.html#a16f81fd43d3db2bfa54d66d06df294e6">cleanup</a> ()</td></tr>
<tr class="memdesc:a16f81fd43d3db2bfa54d66d06df294e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permanently stops all monitoring on replica sets and clears all cached information as well.  <br /></td></tr>
<tr class="separator:a16f81fd43d3db2bfa54d66d06df294e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81a8387e4d94949f223ebc93b12533e"><td class="memItemLeft" align="right" valign="top"><a id="af81a8387e4d94949f223ebc93b12533e" name="af81a8387e4d94949f223ebc93b12533e"></a>
static ScanStatePtr MONGO_CLIENT_FUNC&#160;</td><td class="memItemRight" valign="bottom"><b>startNewScan</b> (const <a class="el" href="structmongo_1_1ReplicaSetMonitor_1_1SetState.html">SetState</a> *set)</td></tr>
<tr class="memdesc:af81a8387e4d94949f223ebc93b12533e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a new scan over the hosts in set. <br /></td></tr>
<tr class="separator:af81a8387e4d94949f223ebc93b12533e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:af6a56db5360943298d7fde841551ebac"><td class="memItemLeft" align="right" valign="top"><a id="af6a56db5360943298d7fde841551ebac" name="af6a56db5360943298d7fde841551ebac"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>maxConsecutiveFailedChecks</b></td></tr>
<tr class="memdesc:af6a56db5360943298d7fde841551ebac"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a <a class="el" href="classmongo_1_1ReplicaSetMonitor.html" title="Holds state about a replica set and provides a means to refresh the local view.">ReplicaSetMonitor</a> has been refreshed more than this many times in a row without finding any live nodes claiming to be in the set, the ReplicaSetMonitorWatcher will stop periodic background refreshes of this set. <br /></td></tr>
<tr class="separator:af6a56db5360943298d7fde841551ebac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5619f02277d49a0b17e5864b886da54"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1ReplicaSetMonitor.html#af5619f02277d49a0b17e5864b886da54">useDeterministicHostSelection</a></td></tr>
<tr class="memdesc:af5619f02277d49a0b17e5864b886da54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaults to false, meaning that if multiple hosts meet a criteria we pick one at random.  <br /></td></tr>
<tr class="separator:af5619f02277d49a0b17e5864b886da54"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Holds state about a replica set and provides a means to refresh the local view. </p>
<p>Refreshes the local view of a replica set.</p>
<p>All methods perform the required synchronization to allow callers from multiple threads.</p>
<p>Use <a class="el" href="classmongo_1_1ReplicaSetMonitor.html#a61b9142e147364322c0868022182777b" title="Returns a refresher object that can be used to update our view of the set.">ReplicaSetMonitor::startOrContinueRefresh()</a> to obtain a Refresher.</p>
<p>Multiple threads can refresh a single set without any additional synchronization, however they must each use their own Refresher object.</p>
<p>All logic related to choosing the hosts to contact and updating the <a class="el" href="structmongo_1_1ReplicaSetMonitor_1_1SetState.html">SetState</a> based on replies lives in this class. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa31cc064ed6f97cca5190304bfb47812" name="aa31cc064ed6f97cca5190304bfb47812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa31cc064ed6f97cca5190304bfb47812">&#9670;&#160;</a></span>ReplicaSetMonitor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mongo::ReplicaSetMonitor::ReplicaSetMonitor </td>
          <td>(</td>
          <td class="paramtype">StringData&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="structmongo_1_1HostAndPort.html">HostAndPort</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>seeds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes local state. </p>
<p>seeds must not be empty. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a16f81fd43d3db2bfa54d66d06df294e6" name="a16f81fd43d3db2bfa54d66d06df294e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f81fd43d3db2bfa54d66d06df294e6">&#9670;&#160;</a></span>cleanup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void MONGO_CLIENT_FUNC mongo::ReplicaSetMonitor::cleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permanently stops all monitoring on replica sets and clears all cached information as well. </p>
<p>As a consequence, NEVER call this if you have other threads that have a <a class="el" href="classmongo_1_1DBClientReplicaSet.html" title="Use this class to connect to a replica set of servers.">DBClientReplicaSet</a> instance. </p>

</div>
</div>
<a id="a07049d6895d074584d0e653fb4614a50" name="a07049d6895d074584d0e653fb4614a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07049d6895d074584d0e653fb4614a50">&#9670;&#160;</a></span>failedHost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mongo::ReplicaSetMonitor::failedHost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmongo_1_1HostAndPort.html">HostAndPort</a> &amp;&#160;</td>
          <td class="paramname"><em>host</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notifies this Monitor that a host has failed and should be considered down. </p>
<p>Call this when you get a connection error. If you get an error while trying to refresh our view of a host, call Refresher::hostFailed() instead. </p>

</div>
</div>
<a id="a61a3b0cc91d7566b477a1e21a27c1b68" name="a61a3b0cc91d7566b477a1e21a27c1b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a3b0cc91d7566b477a1e21a27c1b68">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ReplicaSetMonitorPtr MONGO_CLIENT_FUNC mongo::ReplicaSetMonitor::get </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>createFromSeed</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>gets a cached Monitor per name. </p>
<p>If the monitor is not found and createFromSeed is false, it will return none. If createFromSeed is true, it will try to look up the last known servers list for this set and will create a new monitor using that as the seed list. </p>

</div>
</div>
<a id="a62b9158339c4762dda3303c0f1d21d42" name="a62b9158339c4762dda3303c0f1d21d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b9158339c4762dda3303c0f1d21d42">&#9670;&#160;</a></span>getHostOrRefresh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmongo_1_1HostAndPort.html">HostAndPort</a> mongo::ReplicaSetMonitor::getHostOrRefresh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmongo_1_1ReadPreferenceSetting.html">ReadPreferenceSetting</a> &amp;&#160;</td>
          <td class="paramname"><em>criteria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a host matching criteria or an empty <a class="el" href="structmongo_1_1HostAndPort.html" title="helper for manipulating host:port connection endpoints.">HostAndPort</a> if no host matches. </p>
<p>If no host matches initially, will then attempt to refresh our view of the set by contacting other hosts. May still return no result if no host matches following a refresh. </p>

</div>
</div>
<a id="acc78b4c336cec685a4ca13e00ba0337b" name="acc78b4c336cec685a4ca13e00ba0337b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc78b4c336cec685a4ca13e00ba0337b">&#9670;&#160;</a></span>getMasterOrUassert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmongo_1_1HostAndPort.html">HostAndPort</a> mongo::ReplicaSetMonitor::getMasterOrUassert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the host we think is the current master or uasserts. </p>
<p>This is a thin wrapper around getHostOrRefresh so this will also refresh our view if we don't think there is a master at first. The main difference is that this will uassert rather than returning an empty <a class="el" href="structmongo_1_1HostAndPort.html" title="helper for manipulating host:port connection endpoints.">HostAndPort</a>. </p>

</div>
</div>
<a id="a422b4b9f08eea0abdfb24dc41d7d9a15" name="a422b4b9f08eea0abdfb24dc41d7d9a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422b4b9f08eea0abdfb24dc41d7d9a15">&#9670;&#160;</a></span>getNextStep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmongo_1_1ReplicaSetMonitor_1_1NextStep.html">NextStep</a> mongo::ReplicaSetMonitor::getNextStep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the next step to take. </p>
<p>By calling this, you promise to call receivedIsMaster or failedHost if the <a class="el" href="structmongo_1_1ReplicaSetMonitor_1_1NextStep.html">NextStep</a> is CONTACT_HOST. </p>

</div>
</div>
<a id="ad197683d25912ea06d6d2e9363e7b74a" name="ad197683d25912ea06d6d2e9363e7b74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad197683d25912ea06d6d2e9363e7b74a">&#9670;&#160;</a></span>getServerAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mongo::ReplicaSetMonitor::getServerAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string with the format name/server1,server2. </p>
<p>If name is empty, returns just comma-separated list of servers. </p>

</div>
</div>
<a id="a0f4616bbd03ab8cd6b9e38f43cbb80a3" name="a0f4616bbd03ab8cd6b9e38f43cbb80a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f4616bbd03ab8cd6b9e38f43cbb80a3">&#9670;&#160;</a></span>isPrimary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mongo::ReplicaSetMonitor::isPrimary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmongo_1_1HostAndPort.html">HostAndPort</a> &amp;&#160;</td>
          <td class="paramname"><em>host</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this node is the master based ONLY on local data. </p>
<p>Be careful, return may be stale. </p>

</div>
</div>
<a id="aa366c8e68287f832beac97003900944a" name="aa366c8e68287f832beac97003900944a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa366c8e68287f832beac97003900944a">&#9670;&#160;</a></span>receivedIsMaster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mongo::ReplicaSetMonitor::receivedIsMaster </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmongo_1_1HostAndPort.html">HostAndPort</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>latencyMicros</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> &amp;&#160;</td>
          <td class="paramname"><em>reply</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this if a host returned from getNextStep successfully replied to an isMaster call. </p>
<p>Negative latencyMicros are ignored. </p>

</div>
</div>
<a id="ac48f698ac7a18221fb5515017646e42f" name="ac48f698ac7a18221fb5515017646e42f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48f698ac7a18221fb5515017646e42f">&#9670;&#160;</a></span>refreshAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mongo::ReplicaSetMonitor::refreshAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Refresh all hosts. </p>
<p>Equivalent to refreshUntilMatches with a criteria that never matches.</p>
<p>This is intended to be called periodically, possibly from a background thread. </p>

</div>
</div>
<a id="a84e83e848d3b109ca37d294c5cac0856" name="a84e83e848d3b109ca37d294c5cac0856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e83e848d3b109ca37d294c5cac0856">&#9670;&#160;</a></span>Refresher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mongo::ReplicaSetMonitor::Refresher </td>
          <td>(</td>
          <td class="paramtype">const SetStatePtr &amp;&#160;</td>
          <td class="paramname"><em>setState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Any passed-in pointers are shared with caller. </p>
<p>If no scan is in-progress, this function is responsible for setting up a new scan. </p>

</div>
</div>
<a id="ac242e9150b7e611600486cd30ed954e2" name="ac242e9150b7e611600486cd30ed954e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac242e9150b7e611600486cd30ed954e2">&#9670;&#160;</a></span>refreshUntilMatches()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmongo_1_1HostAndPort.html">HostAndPort</a> mongo::ReplicaSetMonitor::refreshUntilMatches </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmongo_1_1ReadPreferenceSetting.html">ReadPreferenceSetting</a> &amp;&#160;</td>
          <td class="paramname"><em>criteria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contact hosts in the set to refresh our view, but stop once a host matches criteria. </p>
<p>Returns the matching host or empty if none match after a refresh.</p>
<p>This is called by ReplicaSetMonitor::getHostWithRefresh() </p>

</div>
</div>
<a id="a038df358175462298aede902eb26f31f" name="a038df358175462298aede902eb26f31f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a038df358175462298aede902eb26f31f">&#9670;&#160;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void MONGO_CLIENT_FUNC mongo::ReplicaSetMonitor::remove </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clearSeedCache</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the <a class="el" href="classmongo_1_1ReplicaSetMonitor.html" title="Holds state about a replica set and provides a means to refresh the local view.">ReplicaSetMonitor</a> for the given set name from _sets, which will delete it. </p>
<p>If clearSeedCache is true, then the cached seed string for this Replica Set will be removed from _seedServers. </p>

</div>
</div>
<a id="ae6626a0a68f5461d46c8a85f60061a1b" name="ae6626a0a68f5461d46c8a85f60061a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6626a0a68f5461d46c8a85f60061a1b">&#9670;&#160;</a></span>setConfigChangeHook()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void MONGO_CLIENT_FUNC mongo::ReplicaSetMonitor::setConfigChangeHook </td>
          <td>(</td>
          <td class="paramtype">ConfigChangeHook&#160;</td>
          <td class="paramname"><em>hook</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the hook to be called whenever the config of any replica set changes. </p>
<p>Currently only 1 globally, so this asserts if one already exists.</p>
<p>The hook will be called from a fresh thread. It is responsible for initializing any thread-local state and ensuring that no exceptions escape.</p>
<p>The hook must not be changed while the program has multiple threads. </p>

</div>
</div>
<a id="a61b9142e147364322c0868022182777b" name="a61b9142e147364322c0868022182777b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b9142e147364322c0868022182777b">&#9670;&#160;</a></span>startOrContinueRefresh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmongo_1_1ReplicaSetMonitor.html#a84e83e848d3b109ca37d294c5cac0856">Refresher</a> mongo::ReplicaSetMonitor::startOrContinueRefresh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a refresher object that can be used to update our view of the set. </p>
<p>If a refresh is currently in-progress, the returned Refresher will participate in the current refresh round. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af5619f02277d49a0b17e5864b886da54" name="af5619f02277d49a0b17e5864b886da54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5619f02277d49a0b17e5864b886da54">&#9670;&#160;</a></span>useDeterministicHostSelection</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mongo::ReplicaSetMonitor::useDeterministicHostSelection</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defaults to false, meaning that if multiple hosts meet a criteria we pick one at random. </p>
<p>This is required by the replica set driver spec. Set this to true in tests that need host selection to be deterministic. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/mongo/client/<a class="el" href="replica__set__monitor_8h_source.html">replica_set_monitor.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
