<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MongoDB C++ Driver: mongo::BSONObj Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MongoDB C++ Driver
   &#160;<span id="projectnumber">legacy-1.0.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemongo.html">mongo</a></li><li class="navelem"><a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classmongo_1_1BSONObj-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mongo::BSONObj Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>C++ representation of a "BSON" object &ndash; that is, an extended JSON-style object in a binary representation.  
 <a href="classmongo_1_1BSONObj.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="bsonobj_8h_source.html">bsonobj.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for mongo::BSONObj:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classmongo_1_1BSONObj.png" usemap="#mongo::BSONObj_map" alt=""/>
  <map id="mongo::BSONObj_map" name="mongo::BSONObj_map">
<area href="structmongo_1_1BSONArray.html" alt="mongo::BSONArray" shape="rect" coords="0,56,123,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmongo_1_1BSONObj_1_1Hasher.html">Hasher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor compatible with std::hash for std::unordered_{map,set} Warning: The hash function is subject to change.  <a href="structmongo_1_1BSONObj_1_1Hasher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9116833b917fd4719bcafc9377d8b8b3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="memdesc:a9116833b917fd4719bcafc9377d8b8b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Readable representation of a BSON object in an extended JSON-style notation.  <a href="classmongo_1_1BSONObj.html#a9116833b917fd4719bcafc9377d8b8b3">More...</a><br /></td></tr>
<tr class="separator:a9116833b917fd4719bcafc9377d8b8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae7acc6eba069e9405f63d476823e4b2f"><td class="memItemLeft" align="right" valign="top"><a id="ae7acc6eba069e9405f63d476823e4b2f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#ae7acc6eba069e9405f63d476823e4b2f">BSONObj</a> ()</td></tr>
<tr class="memdesc:ae7acc6eba069e9405f63d476823e4b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty <a class="el" href="classmongo_1_1BSONObj.html" title="C++ representation of a &quot;BSON&quot; object – that is, an extended JSON-style object in a binary representa...">BSONObj</a> &ndash; that is, {}. <br /></td></tr>
<tr class="separator:ae7acc6eba069e9405f63d476823e4b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849183537e4dd5af73f39c6aa7912f88"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#a849183537e4dd5af73f39c6aa7912f88">BSONObj</a> (const char *bsonData)</td></tr>
<tr class="memdesc:a849183537e4dd5af73f39c6aa7912f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classmongo_1_1BSONObj.html" title="C++ representation of a &quot;BSON&quot; object – that is, an extended JSON-style object in a binary representa...">BSONObj</a> from data in the proper format.  <a href="classmongo_1_1BSONObj.html#a849183537e4dd5af73f39c6aa7912f88">More...</a><br /></td></tr>
<tr class="separator:a849183537e4dd5af73f39c6aa7912f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a50fe1cedb06c0edd710785d45b840"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#ae7a50fe1cedb06c0edd710785d45b840">operator=</a> (<a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> otherCopy)</td></tr>
<tr class="memdesc:ae7a50fe1cedb06c0edd710785d45b840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide assignment semantics.  <a href="classmongo_1_1BSONObj.html#ae7a50fe1cedb06c0edd710785d45b840">More...</a><br /></td></tr>
<tr class="separator:ae7a50fe1cedb06c0edd710785d45b840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8244df350c67c30fbeae486ef545125"><td class="memItemLeft" align="right" valign="top"><a id="ab8244df350c67c30fbeae486ef545125"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#ab8244df350c67c30fbeae486ef545125">swap</a> (<a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> &amp;other)</td></tr>
<tr class="memdesc:ab8244df350c67c30fbeae486ef545125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap this <a class="el" href="classmongo_1_1BSONObj.html" title="C++ representation of a &quot;BSON&quot; object – that is, an extended JSON-style object in a binary representa...">BSONObj</a> with 'other'. <br /></td></tr>
<tr class="separator:ab8244df350c67c30fbeae486ef545125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16005e5a675fa97cbbf47844d7abf0e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#a16005e5a675fa97cbbf47844d7abf0e9">isOwned</a> () const</td></tr>
<tr class="memdesc:a16005e5a675fa97cbbf47844d7abf0e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classmongo_1_1BSONObj.html" title="C++ representation of a &quot;BSON&quot; object – that is, an extended JSON-style object in a binary representa...">BSONObj</a> can use a buffer it "owns" or one it does not.  <a href="classmongo_1_1BSONObj.html#a16005e5a675fa97cbbf47844d7abf0e9">More...</a><br /></td></tr>
<tr class="separator:a16005e5a675fa97cbbf47844d7abf0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d783f65ccbc102b518fa01f29ef56bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#a6d783f65ccbc102b518fa01f29ef56bb">getOwned</a> () const</td></tr>
<tr class="memdesc:a6d783f65ccbc102b518fa01f29ef56bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">assure the data buffer is under the control of this <a class="el" href="classmongo_1_1BSONObj.html" title="C++ representation of a &quot;BSON&quot; object – that is, an extended JSON-style object in a binary representa...">BSONObj</a> and not a remote buffer  <a href="classmongo_1_1BSONObj.html#a6d783f65ccbc102b518fa01f29ef56bb">More...</a><br /></td></tr>
<tr class="separator:a6d783f65ccbc102b518fa01f29ef56bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ec668040db049d502f139a29492a7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#a55ec668040db049d502f139a29492a7c">copy</a> () const</td></tr>
<tr class="separator:a55ec668040db049d502f139a29492a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc21f568d2e69b060a6123f533813e7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#a6fc21f568d2e69b060a6123f533813e7">jsonString</a> (<a class="el" href="namespacemongo.html#a2767df491e3691937fa3b671ad3248a8">JsonStringFormat</a> format=<a class="el" href="namespacemongo.html#a2767df491e3691937fa3b671ad3248a8a4146675f73f8dc5ba08b78a00fecbbea">Strict</a>, int pretty=0, bool <a class="el" href="namespacemongo.html#a297df4a67448097c9e4307552a8a50d7">isArray</a>=false) const</td></tr>
<tr class="memdesc:a6fc21f568d2e69b060a6123f533813e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Properly formatted JSON string.  <a href="classmongo_1_1BSONObj.html#a6fc21f568d2e69b060a6123f533813e7">More...</a><br /></td></tr>
<tr class="separator:a6fc21f568d2e69b060a6123f533813e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4a8c84481fef922c351a49386503b2"><td class="memItemLeft" align="right" valign="top"><a id="a0a4a8c84481fef922c351a49386503b2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#a0a4a8c84481fef922c351a49386503b2">addFields</a> (<a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> &amp;from, std::set&lt; std::string &gt; &amp;fields)</td></tr>
<tr class="memdesc:a0a4a8c84481fef922c351a49386503b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">note: addFields always adds _id even if not specified <br /></td></tr>
<tr class="separator:a0a4a8c84481fef922c351a49386503b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af002047ab61ab04c2c2f4813431f839e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#af002047ab61ab04c2c2f4813431f839e">removeField</a> (const StringData &amp;name) const</td></tr>
<tr class="memdesc:af002047ab61ab04c2c2f4813431f839e"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove specified field and return a new object with the remaining fields.  <a href="classmongo_1_1BSONObj.html#af002047ab61ab04c2c2f4813431f839e">More...</a><br /></td></tr>
<tr class="separator:af002047ab61ab04c2c2f4813431f839e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae521ab2b7234888e1e419a45110f5ccf"><td class="memItemLeft" align="right" valign="top"><a id="ae521ab2b7234888e1e419a45110f5ccf"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#ae521ab2b7234888e1e419a45110f5ccf">nFields</a> () const</td></tr>
<tr class="memdesc:ae521ab2b7234888e1e419a45110f5ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns # of top level fields in the object note: iterates to count the fields <br /></td></tr>
<tr class="separator:ae521ab2b7234888e1e419a45110f5ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd792e28a3e7a52ff64ed0afb4459f2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#a2dd792e28a3e7a52ff64ed0afb4459f2">getFieldNames</a> (std::set&lt; std::string &gt; &amp;fields) const</td></tr>
<tr class="memdesc:a2dd792e28a3e7a52ff64ed0afb4459f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds the field names to the fields set.  <a href="classmongo_1_1BSONObj.html#a2dd792e28a3e7a52ff64ed0afb4459f2">More...</a><br /></td></tr>
<tr class="separator:a2dd792e28a3e7a52ff64ed0afb4459f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba233faf13ec0f2313ddc00d3c6f4487"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmongo_1_1BSONElement.html">BSONElement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#aba233faf13ec0f2313ddc00d3c6f4487">getFieldDotted</a> (const StringData &amp;name) const</td></tr>
<tr class="separator:aba233faf13ec0f2313ddc00d3c6f4487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6916c0fdb86df044b0263fa497a0f6f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#a6916c0fdb86df044b0263fa497a0f6f4">getFieldsDotted</a> (const StringData &amp;name, BSONElementSet &amp;ret, bool expandLastArray=true) const</td></tr>
<tr class="memdesc:a6916c0fdb86df044b0263fa497a0f6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="classmongo_1_1BSONObj.html#aba233faf13ec0f2313ddc00d3c6f4487">getFieldDotted()</a>, but expands arrays and returns all matching objects.  <a href="classmongo_1_1BSONObj.html#a6916c0fdb86df044b0263fa497a0f6f4">More...</a><br /></td></tr>
<tr class="separator:a6916c0fdb86df044b0263fa497a0f6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514b5c62f55ec6f528abfa630433fcc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmongo_1_1BSONElement.html">BSONElement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#a514b5c62f55ec6f528abfa630433fcc3">getFieldDottedOrArray</a> (const char *&amp;name) const</td></tr>
<tr class="memdesc:a514b5c62f55ec6f528abfa630433fcc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="classmongo_1_1BSONObj.html#aba233faf13ec0f2313ddc00d3c6f4487">getFieldDotted()</a>, but returns first array encountered while traversing the dotted fields of name.  <a href="classmongo_1_1BSONObj.html#a514b5c62f55ec6f528abfa630433fcc3">More...</a><br /></td></tr>
<tr class="separator:a514b5c62f55ec6f528abfa630433fcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d60fda6625861a7bd18befccba0794"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmongo_1_1BSONElement.html">BSONElement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#af2d60fda6625861a7bd18befccba0794">getField</a> (const StringData &amp;name) const</td></tr>
<tr class="memdesc:af2d60fda6625861a7bd18befccba0794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the field of the specified name.  <a href="classmongo_1_1BSONObj.html#af2d60fda6625861a7bd18befccba0794">More...</a><br /></td></tr>
<tr class="separator:af2d60fda6625861a7bd18befccba0794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005e96f592353b9c9f9161d814a7bc34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#a005e96f592353b9c9f9161d814a7bc34">getFields</a> (unsigned n, const char **fieldNames, <a class="el" href="classmongo_1_1BSONElement.html">BSONElement</a> *fields) const</td></tr>
<tr class="memdesc:a005e96f592353b9c9f9161d814a7bc34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get several fields at once.  <a href="classmongo_1_1BSONObj.html#a005e96f592353b9c9f9161d814a7bc34">More...</a><br /></td></tr>
<tr class="separator:a005e96f592353b9c9f9161d814a7bc34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba0606b6de1bcb8e0f3f2871441808b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmongo_1_1BSONElement.html">BSONElement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#a6ba0606b6de1bcb8e0f3f2871441808b">operator[]</a> (const StringData &amp;field) const</td></tr>
<tr class="memdesc:a6ba0606b6de1bcb8e0f3f2871441808b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the field of the specified name.  <a href="classmongo_1_1BSONObj.html#a6ba0606b6de1bcb8e0f3f2871441808b">More...</a><br /></td></tr>
<tr class="separator:a6ba0606b6de1bcb8e0f3f2871441808b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57eed610a72cac1687adf2df4fd07ab7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#a57eed610a72cac1687adf2df4fd07ab7">hasField</a> (const StringData &amp;name) const</td></tr>
<tr class="separator:a57eed610a72cac1687adf2df4fd07ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c56f23b2b85168efcedf54c1344415"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#af4c56f23b2b85168efcedf54c1344415">hasElement</a> (const StringData &amp;name) const</td></tr>
<tr class="separator:af4c56f23b2b85168efcedf54c1344415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8c0bd5615c4c69e48e2f6d20f76a57"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#aed8c0bd5615c4c69e48e2f6d20f76a57">getStringField</a> (const StringData &amp;name) const</td></tr>
<tr class="separator:aed8c0bd5615c4c69e48e2f6d20f76a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2add74580fa4c6561301fa7536ef2a6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#a2add74580fa4c6561301fa7536ef2a6f">getObjectField</a> (const StringData &amp;name) const</td></tr>
<tr class="separator:a2add74580fa4c6561301fa7536ef2a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88151c0ed5905eccb6beb8f78a6fe40"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#ae88151c0ed5905eccb6beb8f78a6fe40">getIntField</a> (const StringData &amp;name) const</td></tr>
<tr class="separator:ae88151c0ed5905eccb6beb8f78a6fe40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26428932791a24d2f3f173ceb981a779"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#a26428932791a24d2f3f173ceb981a779">getBoolField</a> (const StringData &amp;name) const</td></tr>
<tr class="separator:a26428932791a24d2f3f173ceb981a779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ce8bb4c844d21c6c1778245f758597"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#af7ce8bb4c844d21c6c1778245f758597">extractFieldsUnDotted</a> (const <a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> &amp;pattern) const</td></tr>
<tr class="separator:af7ce8bb4c844d21c6c1778245f758597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2b6c7a6751127b9f7c99b92a6f5bc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#a6a2b6c7a6751127b9f7c99b92a6f5bc9">extractFields</a> (const <a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> &amp;pattern, bool fillWithNull=false) const</td></tr>
<tr class="memdesc:a6a2b6c7a6751127b9f7c99b92a6f5bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract items from object which match a pattern object.  <a href="classmongo_1_1BSONObj.html#a6a2b6c7a6751127b9f7c99b92a6f5bc9">More...</a><br /></td></tr>
<tr class="separator:a6a2b6c7a6751127b9f7c99b92a6f5bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ced0a0c2874b04c6ca3bc433a4b68f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#a4ced0a0c2874b04c6ca3bc433a4b68f4">couldBeArray</a> () const</td></tr>
<tr class="memdesc:a4ced0a0c2874b04c6ca3bc433a4b68f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">arrays are bson objects with numeric and increasing field names  <a href="classmongo_1_1BSONObj.html#a4ced0a0c2874b04c6ca3bc433a4b68f4">More...</a><br /></td></tr>
<tr class="separator:a4ced0a0c2874b04c6ca3bc433a4b68f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707be606d530d33dfea72a3f9c645860"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#a707be606d530d33dfea72a3f9c645860">objdata</a> () const</td></tr>
<tr class="separator:a707be606d530d33dfea72a3f9c645860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de93faf496a681fee4e6cdfab9d087e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#a7de93faf496a681fee4e6cdfab9d087e">objsize</a> () const</td></tr>
<tr class="separator:a7de93faf496a681fee4e6cdfab9d087e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fce465c24677bc67c45427dd9f49c75"><td class="memItemLeft" align="right" valign="top"><a id="a7fce465c24677bc67c45427dd9f49c75"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#a7fce465c24677bc67c45427dd9f49c75">isValid</a> () const</td></tr>
<tr class="memdesc:a7fce465c24677bc67c45427dd9f49c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs a cursory check on the object's size only. <br /></td></tr>
<tr class="separator:a7fce465c24677bc67c45427dd9f49c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0389878dcdcdb50812e38b5859174b1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#a0389878dcdcdb50812e38b5859174b1a">okForStorage</a> () const</td></tr>
<tr class="separator:a0389878dcdcdb50812e38b5859174b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b2426af9d41976ba2a546ab2d07c34"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#a37b2426af9d41976ba2a546ab2d07c34">okForStorageAsRoot</a> () const</td></tr>
<tr class="memdesc:a37b2426af9d41976ba2a546ab2d07c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above with the following extra restrictions Not valid if:  <a href="classmongo_1_1BSONObj.html#a37b2426af9d41976ba2a546ab2d07c34">More...</a><br /></td></tr>
<tr class="separator:a37b2426af9d41976ba2a546ab2d07c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ede7549777f56947466366c409279f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemongo.html#a6ee35cd59a3a5a21c98b430345c35401">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#a31ede7549777f56947466366c409279f">storageValidEmbedded</a> (const bool deep=true) const</td></tr>
<tr class="memdesc:a31ede7549777f56947466366c409279f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates that this can be stored as an embedded document See details above in okForStorage.  <a href="classmongo_1_1BSONObj.html#a31ede7549777f56947466366c409279f">More...</a><br /></td></tr>
<tr class="separator:a31ede7549777f56947466366c409279f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c3b861c3e9f4b22e45307bda5f7ad9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemongo.html#a6ee35cd59a3a5a21c98b430345c35401">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#aa0c3b861c3e9f4b22e45307bda5f7ad9">storageValid</a> (const bool deep=true) const</td></tr>
<tr class="memdesc:aa0c3b861c3e9f4b22e45307bda5f7ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates that this can be stored as a document (in a collection) See details above in okForStorageAsRoot.  <a href="classmongo_1_1BSONObj.html#aa0c3b861c3e9f4b22e45307bda5f7ad9">More...</a><br /></td></tr>
<tr class="separator:aa0c3b861c3e9f4b22e45307bda5f7ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac315c18d063546688e1df8920d6d9318"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#ac315c18d063546688e1df8920d6d9318">isEmpty</a> () const</td></tr>
<tr class="separator:ac315c18d063546688e1df8920d6d9318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61d5e7795dab1b5770f8bfa1b75981f"><td class="memItemLeft" align="right" valign="top"><a id="ae61d5e7795dab1b5770f8bfa1b75981f"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#ae61d5e7795dab1b5770f8bfa1b75981f">hexDump</a> () const</td></tr>
<tr class="memdesc:ae61d5e7795dab1b5770f8bfa1b75981f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative output format. <br /></td></tr>
<tr class="separator:ae61d5e7795dab1b5770f8bfa1b75981f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceae20d8f96355101aa7e33764e14da1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#aceae20d8f96355101aa7e33764e14da1">woCompare</a> (const <a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> &amp;r, const <a class="el" href="classmongo_1_1Ordering.html">Ordering</a> &amp;o, bool considerFieldName=true) const</td></tr>
<tr class="memdesc:aceae20d8f96355101aa7e33764e14da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">wo='well ordered'.  <a href="classmongo_1_1BSONObj.html#aceae20d8f96355101aa7e33764e14da1">More...</a><br /></td></tr>
<tr class="separator:aceae20d8f96355101aa7e33764e14da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ca0672a114d56dc346744990ce6d10"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#a03ca0672a114d56dc346744990ce6d10">woCompare</a> (const <a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> &amp;r, const <a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> &amp;ordering=<a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a>(), bool considerFieldName=true) const</td></tr>
<tr class="memdesc:a03ca0672a114d56dc346744990ce6d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">wo='well ordered'.  <a href="classmongo_1_1BSONObj.html#a03ca0672a114d56dc346744990ce6d10">More...</a><br /></td></tr>
<tr class="separator:a03ca0672a114d56dc346744990ce6d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dea159b38f5f044ccd9cc3f81afc114"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#a8dea159b38f5f044ccd9cc3f81afc114">woSortOrder</a> (const <a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> &amp;r, const <a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> &amp;sortKey, bool useDotted=false) const</td></tr>
<tr class="separator:a8dea159b38f5f044ccd9cc3f81afc114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9fe6083cdb6cfb3a806132735f351d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#aba9fe6083cdb6cfb3a806132735f351d">isPrefixOf</a> (const <a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> &amp;otherObj) const</td></tr>
<tr class="separator:aba9fe6083cdb6cfb3a806132735f351d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db2dd048ae10a98566ada306b4e5947"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#a8db2dd048ae10a98566ada306b4e5947">isFieldNamePrefixOf</a> (const <a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> &amp;otherObj) const</td></tr>
<tr class="separator:a8db2dd048ae10a98566ada306b4e5947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab756268915c0e8bdc3a361522ae0d4d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#ab756268915c0e8bdc3a361522ae0d4d1">binaryEqual</a> (const <a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> &amp;r) const</td></tr>
<tr class="memdesc:ab756268915c0e8bdc3a361522ae0d4d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is "shallow equality" &ndash; ints and doubles won't match.  <a href="classmongo_1_1BSONObj.html#ab756268915c0e8bdc3a361522ae0d4d1">More...</a><br /></td></tr>
<tr class="separator:ab756268915c0e8bdc3a361522ae0d4d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce278436d63950618d3409060ac6b16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmongo_1_1BSONElement.html">BSONElement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#afce278436d63950618d3409060ac6b16">firstElement</a> () const</td></tr>
<tr class="separator:afce278436d63950618d3409060ac6b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4dcdeea57c3b1bdd49ff1644b91116f"><td class="memItemLeft" align="right" valign="top"><a id="ae4dcdeea57c3b1bdd49ff1644b91116f"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#ae4dcdeea57c3b1bdd49ff1644b91116f">firstElementFieldName</a> () const</td></tr>
<tr class="memdesc:ae4dcdeea57c3b1bdd49ff1644b91116f"><td class="mdescLeft">&#160;</td><td class="mdescRight">faster than <a class="el" href="classmongo_1_1BSONObj.html#afce278436d63950618d3409060ac6b16">firstElement()</a>.fieldName() - for the first element we can easily find the fieldname without computing the element size. <br /></td></tr>
<tr class="separator:ae4dcdeea57c3b1bdd49ff1644b91116f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015478f9bc53fae0f1d96d6c84f0207d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#a015478f9bc53fae0f1d96d6c84f0207d">getObjectID</a> (<a class="el" href="classmongo_1_1BSONElement.html">BSONElement</a> &amp;e) const</td></tr>
<tr class="memdesc:a015478f9bc53fae0f1d96d6c84f0207d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the _id field from the object.  <a href="classmongo_1_1BSONObj.html#a015478f9bc53fae0f1d96d6c84f0207d">More...</a><br /></td></tr>
<tr class="separator:a015478f9bc53fae0f1d96d6c84f0207d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841976a28f2f8d074884aa321a2b32c6"><td class="memItemLeft" align="right" valign="top"><a id="a841976a28f2f8d074884aa321a2b32c6"></a>
<a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#a841976a28f2f8d074884aa321a2b32c6">replaceFieldNames</a> (const <a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> &amp;obj) const</td></tr>
<tr class="memdesc:a841976a28f2f8d074884aa321a2b32c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return new object with the field names replaced by those in the passed object. <br /></td></tr>
<tr class="separator:a841976a28f2f8d074884aa321a2b32c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95f46604895ad6b1c4e75b3ed39d7d9"><td class="memItemLeft" align="right" valign="top"><a id="ad95f46604895ad6b1c4e75b3ed39d7d9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#ad95f46604895ad6b1c4e75b3ed39d7d9">valid</a> () const</td></tr>
<tr class="memdesc:ad95f46604895ad6b1c4e75b3ed39d7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">true unless corrupt <br /></td></tr>
<tr class="separator:ad95f46604895ad6b1c4e75b3ed39d7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20579e40bc553884a5668672f127be5"><td class="memItemLeft" align="right" valign="top"><a id="aa20579e40bc553884a5668672f127be5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#aa20579e40bc553884a5668672f127be5">elems</a> (std::vector&lt; <a class="el" href="classmongo_1_1BSONElement.html">BSONElement</a> &gt; &amp;) const</td></tr>
<tr class="memdesc:aa20579e40bc553884a5668672f127be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">add all elements of the object to the specified vector <br /></td></tr>
<tr class="separator:aa20579e40bc553884a5668672f127be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f14677a9ba3a84718588855dfd17d0"><td class="memItemLeft" align="right" valign="top"><a id="a82f14677a9ba3a84718588855dfd17d0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#a82f14677a9ba3a84718588855dfd17d0">elems</a> (std::list&lt; <a class="el" href="classmongo_1_1BSONElement.html">BSONElement</a> &gt; &amp;) const</td></tr>
<tr class="memdesc:a82f14677a9ba3a84718588855dfd17d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">add all elements of the object to the specified list <br /></td></tr>
<tr class="separator:a82f14677a9ba3a84718588855dfd17d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6432e93255acf352585ff2d532866b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmongo_1_1BSONObjIterator.html">BSONObjIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#a4f6432e93255acf352585ff2d532866b">begin</a> () const</td></tr>
<tr class="memdesc:a4f6432e93255acf352585ff2d532866b"><td class="mdescLeft">&#160;</td><td class="mdescRight">use something like this: for( BSONObj::iterator i = myObj.begin(); i.more(); ) { <a class="el" href="classmongo_1_1BSONElement.html" title="BSONElement represents an &quot;element&quot; in a BSONObj.">BSONElement</a> e = i.next(); ...  <a href="classmongo_1_1BSONObj.html#a4f6432e93255acf352585ff2d532866b">More...</a><br /></td></tr>
<tr class="separator:a4f6432e93255acf352585ff2d532866b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2583968205bcac84023e521c7c9b3759"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1BSONObj.html#a2583968205bcac84023e521c7c9b3759">takeOwnership</a> (char *holderPrefixedData)</td></tr>
<tr class="memdesc:a2583968205bcac84023e521c7c9b3759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a pointer to a region of un-owned memory containing BSON data, prefixed by sufficient space for a BSONObj::Holder object, return a <a class="el" href="classmongo_1_1BSONObj.html" title="C++ representation of a &quot;BSON&quot; object – that is, an extended JSON-style object in a binary representa...">BSONObj</a> that owns the memory.  <a href="classmongo_1_1BSONObj.html#a2583968205bcac84023e521c7c9b3759">More...</a><br /></td></tr>
<tr class="separator:a2583968205bcac84023e521c7c9b3759"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>C++ representation of a "BSON" object &ndash; that is, an extended JSON-style object in a binary representation. </p>
<p>See bsonspec.org.</p>
<p>Note that <a class="el" href="classmongo_1_1BSONObj.html" title="C++ representation of a &quot;BSON&quot; object – that is, an extended JSON-style object in a binary representa...">BSONObj</a>'s have a smart pointer capability built in &ndash; so you can pass them around by value. The reference counts used to implement this do not use locking, so copying and destroying <a class="el" href="classmongo_1_1BSONObj.html" title="C++ representation of a &quot;BSON&quot; object – that is, an extended JSON-style object in a binary representa...">BSONObj</a>'s are not thread-safe operations.</p>
<p>BSON object format:</p>
<p>code &lt;unsigned totalSize&gt; {&lt;byte BSONType&gt;&lt;cstring FieldName&gt;&lt;Data&gt;}* EOO</p>
<p>totalSize includes itself.</p>
<p>Data: Bool: &lt;byte&gt; EOO: nothing follows Undefined: nothing follows <a class="el" href="classmongo_1_1OID.html" title="Object ID type.">OID</a>: an <a class="el" href="classmongo_1_1OID.html" title="Object ID type.">OID</a> object NumberDouble: &lt;double&gt; NumberInt: &lt;int32&gt; String: &lt;unsigned32 strsizewithnull&gt;&lt;cstring&gt; Date: &lt;8bytes&gt; Regex: &lt;cstring regex&gt;&lt;cstring options&gt; Object: a nested object, leading with its entire size, which terminates with EOO. Array: same as object DBRef: &lt;strlen&gt; &lt;cstring ns&gt; &lt;oid&gt; DBRef: a database reference: basically a collection name plus an Object ID BinData: &lt;int len&gt; &lt;byte subtype&gt; &lt;byte[len] data&gt; Code: a function (not a closure): same format as String. Symbol: a language symbol (say a python symbol). same format as String. Code With Scope: &lt;total size&gt;&lt;String&gt;&lt;Object&gt;  </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a9116833b917fd4719bcafc9377d8b8b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9116833b917fd4719bcafc9377d8b8b3">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Readable representation of a BSON object in an extended JSON-style notation. </p>
<p>This is an abbreviated representation which might be used for logging. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a849183537e4dd5af73f39c6aa7912f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a849183537e4dd5af73f39c6aa7912f88">&#9670;&nbsp;</a></span>BSONObj()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mongo::BSONObj::BSONObj </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>bsonData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classmongo_1_1BSONObj.html" title="C++ representation of a &quot;BSON&quot; object – that is, an extended JSON-style object in a binary representa...">BSONObj</a> from data in the proper format. </p>
<p>Use this constructor when something else owns bsonData's buffer </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4f6432e93255acf352585ff2d532866b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f6432e93255acf352585ff2d532866b">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmongo_1_1BSONObjIterator.html">BSONObjIterator</a> mongo::BSONObj::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>use something like this: for( BSONObj::iterator i = myObj.begin(); i.more(); ) { <a class="el" href="classmongo_1_1BSONElement.html" title="BSONElement represents an &quot;element&quot; in a BSONObj.">BSONElement</a> e = i.next(); ... </p>
<p>} </p>

</div>
</div>
<a id="ab756268915c0e8bdc3a361522ae0d4d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab756268915c0e8bdc3a361522ae0d4d1">&#9670;&nbsp;</a></span>binaryEqual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mongo::BSONObj::binaryEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is "shallow equality" &ndash; ints and doubles won't match. </p>
<p>for a deep equality test use woCompare (which is slower). </p>

</div>
</div>
<a id="a55ec668040db049d502f139a29492a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55ec668040db049d502f139a29492a7c">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> mongo::BSONObj::copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a new full (and owned) copy of the object. </dd></dl>

</div>
</div>
<a id="a4ced0a0c2874b04c6ca3bc433a4b68f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ced0a0c2874b04c6ca3bc433a4b68f4">&#9670;&nbsp;</a></span>couldBeArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mongo::BSONObj::couldBeArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>arrays are bson objects with numeric and increasing field names </p>
<dl class="section return"><dt>Returns</dt><dd>true if field names are numeric and increasing </dd></dl>

</div>
</div>
<a id="a6a2b6c7a6751127b9f7c99b92a6f5bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a2b6c7a6751127b9f7c99b92a6f5bc9">&#9670;&nbsp;</a></span>extractFields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> mongo::BSONObj::extractFields </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fillWithNull</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>extract items from object which match a pattern object. </p>
<p>e.g., if pattern is { x : 1, y : 1 }, builds an object with x and y elements of this object, if they are present. returns elements with original field names </p>

</div>
</div>
<a id="af7ce8bb4c844d21c6c1778245f758597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ce8bb4c844d21c6c1778245f758597">&#9670;&nbsp;</a></span>extractFieldsUnDotted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> mongo::BSONObj::extractFieldsUnDotted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>a BSON obj indicating a set of (un-dotted) field names. Element values are ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a BSON obj constructed by taking the elements of this obj that correspond to the fields in pattern. Field names of the returned object are replaced with the empty string. If field in pattern is missing, it is omitted from the returned object.</dd></dl>
<p>Example: if this = {a : 4 , b : 5 , c : 6}) this.extractFieldsUnDotted({a : 1 , c : 1}) -&gt; {"" : 4 , "" : 6 } this.extractFieldsUnDotted({b : "blah"}) -&gt; {"" : 5} </p>

</div>
</div>
<a id="afce278436d63950618d3409060ac6b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce278436d63950618d3409060ac6b16">&#9670;&nbsp;</a></span>firstElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmongo_1_1BSONElement.html">BSONElement</a> mongo::BSONObj::firstElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>first field of the object </dd></dl>

</div>
</div>
<a id="a26428932791a24d2f3f173ceb981a779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26428932791a24d2f3f173ceb981a779">&#9670;&nbsp;</a></span>getBoolField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mongo::BSONObj::getBoolField </td>
          <td>(</td>
          <td class="paramtype">const StringData &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>false if not present </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmongo_1_1BSONElement.html#abacf00cac7eb2e96a9a86123e840b700" title="Convert the value to boolean, regardless of its type, in a javascript-like fashion (i....">BSONElement::trueValue()</a> </dd></dl>

</div>
</div>
<a id="af2d60fda6625861a7bd18befccba0794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d60fda6625861a7bd18befccba0794">&#9670;&nbsp;</a></span>getField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmongo_1_1BSONElement.html">BSONElement</a> mongo::BSONObj::getField </td>
          <td>(</td>
          <td class="paramtype">const StringData &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the field of the specified name. </p>
<p>eoo() is true on the returned element if not found. </p>

</div>
</div>
<a id="aba233faf13ec0f2313ddc00d3c6f4487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba233faf13ec0f2313ddc00d3c6f4487">&#9670;&nbsp;</a></span>getFieldDotted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmongo_1_1BSONElement.html">BSONElement</a> mongo::BSONObj::getFieldDotted </td>
          <td>(</td>
          <td class="paramtype">const StringData &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the specified element. element.eoo() will be true if not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>field to find. supports dot (".") notation to reach into embedded objects. for example "x.y" means "in the nested object in field x, retrieve field y" </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a514b5c62f55ec6f528abfa630433fcc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a514b5c62f55ec6f528abfa630433fcc3">&#9670;&nbsp;</a></span>getFieldDottedOrArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmongo_1_1BSONElement.html">BSONElement</a> mongo::BSONObj::getFieldDottedOrArray </td>
          <td>(</td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="classmongo_1_1BSONObj.html#aba233faf13ec0f2313ddc00d3c6f4487">getFieldDotted()</a>, but returns first array encountered while traversing the dotted fields of name. </p>
<p>The name variable is updated to represent field names with respect to the returned element. </p>

</div>
</div>
<a id="a2dd792e28a3e7a52ff64ed0afb4459f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dd792e28a3e7a52ff64ed0afb4459f2">&#9670;&nbsp;</a></span>getFieldNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mongo::BSONObj::getFieldNames </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds the field names to the fields set. </p>
<p>does NOT clear it (appends). </p>

</div>
</div>
<a id="a005e96f592353b9c9f9161d814a7bc34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a005e96f592353b9c9f9161d814a7bc34">&#9670;&nbsp;</a></span>getFields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mongo::BSONObj::getFields </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>fieldNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmongo_1_1BSONElement.html">BSONElement</a> *&#160;</td>
          <td class="paramname"><em>fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get several fields at once. </p>
<p>This is faster than separate <a class="el" href="classmongo_1_1BSONObj.html#af2d60fda6625861a7bd18befccba0794" title="Get the field of the specified name.">getField()</a> calls as the size of elements iterated can then be calculated only once each. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>number of fieldNames, and number of elements in the fields array </td></tr>
    <tr><td class="paramname">fields</td><td>if a field is found its element is stored in its corresponding position in this array. if not found the array element is unchanged. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6916c0fdb86df044b0263fa497a0f6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6916c0fdb86df044b0263fa497a0f6f4">&#9670;&nbsp;</a></span>getFieldsDotted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mongo::BSONObj::getFieldsDotted </td>
          <td>(</td>
          <td class="paramtype">const StringData &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BSONElementSet &amp;&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>expandLastArray</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="classmongo_1_1BSONObj.html#aba233faf13ec0f2313ddc00d3c6f4487">getFieldDotted()</a>, but expands arrays and returns all matching objects. </p>
<p>Turning off expandLastArray allows you to retrieve nested array objects instead of their contents. </p>

</div>
</div>
<a id="ae88151c0ed5905eccb6beb8f78a6fe40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88151c0ed5905eccb6beb8f78a6fe40">&#9670;&nbsp;</a></span>getIntField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mongo::BSONObj::getIntField </td>
          <td>(</td>
          <td class="paramtype">const StringData &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>INT_MIN if not present - does some type conversions </dd></dl>

</div>
</div>
<a id="a2add74580fa4c6561301fa7536ef2a6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2add74580fa4c6561301fa7536ef2a6f">&#9670;&nbsp;</a></span>getObjectField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> mongo::BSONObj::getObjectField </td>
          <td>(</td>
          <td class="paramtype">const StringData &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>subobject of the given name </dd></dl>

</div>
</div>
<a id="a015478f9bc53fae0f1d96d6c84f0207d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015478f9bc53fae0f1d96d6c84f0207d">&#9670;&nbsp;</a></span>getObjectID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mongo::BSONObj::getObjectID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmongo_1_1BSONElement.html">BSONElement</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the _id field from the object. </p>
<p>For good performance drivers should assure that _id is the first element of the object; however, correct operation is assured regardless. </p><dl class="section return"><dt>Returns</dt><dd>true if found </dd></dl>

</div>
</div>
<a id="a6d783f65ccbc102b518fa01f29ef56bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d783f65ccbc102b518fa01f29ef56bb">&#9670;&nbsp;</a></span>getOwned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> mongo::BSONObj::getOwned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>assure the data buffer is under the control of this <a class="el" href="classmongo_1_1BSONObj.html" title="C++ representation of a &quot;BSON&quot; object – that is, an extended JSON-style object in a binary representa...">BSONObj</a> and not a remote buffer </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmongo_1_1BSONObj.html#a16005e5a675fa97cbbf47844d7abf0e9" title="A BSONObj can use a buffer it &quot;owns&quot; or one it does not.">isOwned()</a> </dd></dl>

</div>
</div>
<a id="aed8c0bd5615c4c69e48e2f6d20f76a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8c0bd5615c4c69e48e2f6d20f76a57">&#9670;&nbsp;</a></span>getStringField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* mongo::BSONObj::getStringField </td>
          <td>(</td>
          <td class="paramtype">const StringData &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>"" if DNE or wrong type </dd></dl>

</div>
</div>
<a id="af4c56f23b2b85168efcedf54c1344415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c56f23b2b85168efcedf54c1344415">&#9670;&nbsp;</a></span>hasElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mongo::BSONObj::hasElement </td>
          <td>(</td>
          <td class="paramtype">const StringData &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if field exists </dd></dl>

</div>
</div>
<a id="a57eed610a72cac1687adf2df4fd07ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57eed610a72cac1687adf2df4fd07ab7">&#9670;&nbsp;</a></span>hasField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mongo::BSONObj::hasField </td>
          <td>(</td>
          <td class="paramtype">const StringData &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if field exists </dd></dl>

</div>
</div>
<a id="ac315c18d063546688e1df8920d6d9318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac315c18d063546688e1df8920d6d9318">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mongo::BSONObj::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if object is empty &ndash; i.e., {} </dd></dl>

</div>
</div>
<a id="a8db2dd048ae10a98566ada306b4e5947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db2dd048ae10a98566ada306b4e5947">&#9670;&nbsp;</a></span>isFieldNamePrefixOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mongo::BSONObj::isFieldNamePrefixOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> &amp;&#160;</td>
          <td class="paramname"><em>otherObj</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherObj</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns true if the list of field names in 'this' is a prefix of the list of field names in otherObj. Similar to 'isPrefixOf', but ignores the field values and only looks at field names. </dd></dl>

</div>
</div>
<a id="a16005e5a675fa97cbbf47844d7abf0e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16005e5a675fa97cbbf47844d7abf0e9">&#9670;&nbsp;</a></span>isOwned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mongo::BSONObj::isOwned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <a class="el" href="classmongo_1_1BSONObj.html" title="C++ representation of a &quot;BSON&quot; object – that is, an extended JSON-style object in a binary representa...">BSONObj</a> can use a buffer it "owns" or one it does not. </p>
<p>OWNED CASE If the <a class="el" href="classmongo_1_1BSONObj.html" title="C++ representation of a &quot;BSON&quot; object – that is, an extended JSON-style object in a binary representa...">BSONObj</a> owns the buffer, the buffer can be shared among several <a class="el" href="classmongo_1_1BSONObj.html" title="C++ representation of a &quot;BSON&quot; object – that is, an extended JSON-style object in a binary representa...">BSONObj</a>'s (by assignment). In this case the buffer is basically implemented as a shared_ptr. Since <a class="el" href="classmongo_1_1BSONObj.html" title="C++ representation of a &quot;BSON&quot; object – that is, an extended JSON-style object in a binary representa...">BSONObj</a>'s are typically immutable, this works well.</p>
<p>UNOWNED CASE A <a class="el" href="classmongo_1_1BSONObj.html" title="C++ representation of a &quot;BSON&quot; object – that is, an extended JSON-style object in a binary representa...">BSONObj</a> can also point to BSON data in some other data structure it does not "own" or free later. For example, in a memory mapped file. In this case, it is important the original data stays in scope for as long as the <a class="el" href="classmongo_1_1BSONObj.html" title="C++ representation of a &quot;BSON&quot; object – that is, an extended JSON-style object in a binary representa...">BSONObj</a> is in use. If you think the original data may go out of scope, call <a class="el" href="classmongo_1_1BSONObj.html#a6d783f65ccbc102b518fa01f29ef56bb" title="assure the data buffer is under the control of this BSONObj and not a remote buffer">BSONObj::getOwned()</a> to promote your <a class="el" href="classmongo_1_1BSONObj.html" title="C++ representation of a &quot;BSON&quot; object – that is, an extended JSON-style object in a binary representa...">BSONObj</a> to having its own copy.</p>
<p>On a <a class="el" href="classmongo_1_1BSONObj.html" title="C++ representation of a &quot;BSON&quot; object – that is, an extended JSON-style object in a binary representa...">BSONObj</a> assignment, if the source is unowned, both the source and dest will have unowned pointers to the original buffer after the assignment.</p>
<p>If you are not sure about ownership but need the buffer to last as long as the <a class="el" href="classmongo_1_1BSONObj.html" title="C++ representation of a &quot;BSON&quot; object – that is, an extended JSON-style object in a binary representa...">BSONObj</a>, call <a class="el" href="classmongo_1_1BSONObj.html#a6d783f65ccbc102b518fa01f29ef56bb" title="assure the data buffer is under the control of this BSONObj and not a remote buffer">getOwned()</a>. <a class="el" href="classmongo_1_1BSONObj.html#a6d783f65ccbc102b518fa01f29ef56bb" title="assure the data buffer is under the control of this BSONObj and not a remote buffer">getOwned()</a> is a no-op if the buffer is already owned. If not already owned, a malloc and memcpy will result.</p>
<p>Most ways to create <a class="el" href="classmongo_1_1BSONObj.html" title="C++ representation of a &quot;BSON&quot; object – that is, an extended JSON-style object in a binary representa...">BSONObj</a>'s create 'owned' variants. Unowned versions can be created with: (1) specifying true for the ifree parameter in the constructor (2) calling <a class="el" href="classmongo_1_1BSONObjBuilder.html#ae1a64ea2deb887012b7d1d7c5ae47a79" title="Fetch the object we have built.">BSONObjBuilder::done()</a>. Use <a class="el" href="classmongo_1_1BSONObjBuilder.html#ad9310f24c8807ffaf9daf1eda94aaffb" title="destructive The returned BSONObj will free the buffer when it is finished.">BSONObjBuilder::obj()</a> to get an owned copy (3) retrieving a subobject retrieves an unowned pointer into the parent BSON object</p>
<dl class="section return"><dt>Returns</dt><dd>true if this is in owned mode </dd></dl>

</div>
</div>
<a id="aba9fe6083cdb6cfb3a806132735f351d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba9fe6083cdb6cfb3a806132735f351d">&#9670;&nbsp;</a></span>isPrefixOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mongo::BSONObj::isPrefixOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> &amp;&#160;</td>
          <td class="paramname"><em>otherObj</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherObj</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if 'this' is a prefix of otherObj- in other words if otherObj contains the same field names and field vals in the same order as 'this', plus optionally some additional elements. </dd></dl>

</div>
</div>
<a id="a6fc21f568d2e69b060a6123f533813e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc21f568d2e69b060a6123f533813e7">&#9670;&nbsp;</a></span>jsonString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mongo::BSONObj::jsonString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemongo.html#a2767df491e3691937fa3b671ad3248a8">JsonStringFormat</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code><a class="el" href="namespacemongo.html#a2767df491e3691937fa3b671ad3248a8a4146675f73f8dc5ba08b78a00fecbbea">Strict</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pretty</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isArray</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Properly formatted JSON string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pretty</td><td>if true we try to add some lf's and indentation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a707be606d530d33dfea72a3f9c645860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a707be606d530d33dfea72a3f9c645860">&#9670;&nbsp;</a></span>objdata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* mongo::BSONObj::objdata </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the raw data of the object </dd></dl>

</div>
</div>
<a id="a7de93faf496a681fee4e6cdfab9d087e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7de93faf496a681fee4e6cdfab9d087e">&#9670;&nbsp;</a></span>objsize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mongo::BSONObj::objsize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>total size of the BSON object in bytes </dd></dl>

</div>
</div>
<a id="a0389878dcdcdb50812e38b5859174b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0389878dcdcdb50812e38b5859174b1a">&#9670;&nbsp;</a></span>okForStorage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mongo::BSONObj::okForStorage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>ok if it can be stored as a valid embedded doc. Not valid if any field name:<ul>
<li>contains a "."</li>
<li>starts with "$" &ndash; unless it is a dbref ($ref/$id/[$db]/...) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a37b2426af9d41976ba2a546ab2d07c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b2426af9d41976ba2a546ab2d07c34">&#9670;&nbsp;</a></span>okForStorageAsRoot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mongo::BSONObj::okForStorageAsRoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above with the following extra restrictions Not valid if: </p>
<ul>
<li>"_id" field is a &ndash; Regex &ndash; Array </li>
</ul>

</div>
</div>
<a id="ae7a50fe1cedb06c0edd710785d45b840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7a50fe1cedb06c0edd710785d45b840">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a>&amp; mongo::BSONObj::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a>&#160;</td>
          <td class="paramname"><em>otherCopy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide assignment semantics. </p>
<p>We use the value taking form so that we can use copy and swap, and consume both lvalue and rvalue references. </p>

</div>
</div>
<a id="a6ba0606b6de1bcb8e0f3f2871441808b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba0606b6de1bcb8e0f3f2871441808b">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmongo_1_1BSONElement.html">BSONElement</a> mongo::BSONObj::operator[] </td>
          <td>(</td>
          <td class="paramtype">const StringData &amp;&#160;</td>
          <td class="paramname"><em>field</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the field of the specified name. </p>
<p>eoo() is true on the returned element if not found. </p>

</div>
</div>
<a id="af002047ab61ab04c2c2f4813431f839e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af002047ab61ab04c2c2f4813431f839e">&#9670;&nbsp;</a></span>removeField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> mongo::BSONObj::removeField </td>
          <td>(</td>
          <td class="paramtype">const StringData &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>remove specified field and return a new object with the remaining fields. </p>
<p>slowish as builds a full new object </p>

</div>
</div>
<a id="aa0c3b861c3e9f4b22e45307bda5f7ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c3b861c3e9f4b22e45307bda5f7ad9">&#9670;&nbsp;</a></span>storageValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemongo.html#a6ee35cd59a3a5a21c98b430345c35401">Status</a> mongo::BSONObj::storageValid </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>deep</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validates that this can be stored as a document (in a collection) See details above in okForStorageAsRoot. </p>
<p>If 'deep' is true then validation is done to children</p>
<p>If not valid a user readable status message is returned. </p>

</div>
</div>
<a id="a31ede7549777f56947466366c409279f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ede7549777f56947466366c409279f">&#9670;&nbsp;</a></span>storageValidEmbedded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemongo.html#a6ee35cd59a3a5a21c98b430345c35401">Status</a> mongo::BSONObj::storageValidEmbedded </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>deep</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validates that this can be stored as an embedded document See details above in okForStorage. </p>
<p>If 'deep' is true then validation is done to children</p>
<p>If not valid a user readable status message is returned. </p>

</div>
</div>
<a id="a2583968205bcac84023e521c7c9b3759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2583968205bcac84023e521c7c9b3759">&#9670;&nbsp;</a></span>takeOwnership()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> mongo::BSONObj::takeOwnership </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>holderPrefixedData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a pointer to a region of un-owned memory containing BSON data, prefixed by sufficient space for a BSONObj::Holder object, return a <a class="el" href="classmongo_1_1BSONObj.html" title="C++ representation of a &quot;BSON&quot; object – that is, an extended JSON-style object in a binary representa...">BSONObj</a> that owns the memory. </p>
<p>This class will call free(holderPrefixedData), so it must have been allocated in a way that makes that valid. </p>

</div>
</div>
<a id="a03ca0672a114d56dc346744990ce6d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ca0672a114d56dc346744990ce6d10">&#9670;&nbsp;</a></span>woCompare() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mongo::BSONObj::woCompare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> &amp;&#160;</td>
          <td class="paramname"><em>ordering</em> = <code><a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>considerFieldName</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>wo='well ordered'. </p>
<p>fields must be in same order in each object. <a class="el" href="classmongo_1_1Ordering.html" title="A precomputation of a BSON index or sort key pattern.">Ordering</a> is with respect to the signs of the elements and allows ascending / descending key mixing. </p><dl class="section return"><dt>Returns</dt><dd>&lt;0 if l&lt;r. 0 if l==r. &gt;0 if l&gt;r </dd></dl>

</div>
</div>
<a id="aceae20d8f96355101aa7e33764e14da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceae20d8f96355101aa7e33764e14da1">&#9670;&nbsp;</a></span>woCompare() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mongo::BSONObj::woCompare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmongo_1_1Ordering.html">Ordering</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>considerFieldName</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>wo='well ordered'. </p>
<p>fields must be in same order in each object. <a class="el" href="classmongo_1_1Ordering.html" title="A precomputation of a BSON index or sort key pattern.">Ordering</a> is with respect to the signs of the elements and allows ascending / descending key mixing. </p><dl class="section return"><dt>Returns</dt><dd>&lt;0 if l&lt;r. 0 if l==r. &gt;0 if l&gt;r </dd></dl>

</div>
</div>
<a id="a8dea159b38f5f044ccd9cc3f81afc114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dea159b38f5f044ccd9cc3f81afc114">&#9670;&nbsp;</a></span>woSortOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mongo::BSONObj::woSortOrder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmongo_1_1BSONObj.html">BSONObj</a> &amp;&#160;</td>
          <td class="paramname"><em>sortKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useDotted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">useDotted</td><td>whether to treat sort key fields as possibly dotted and expand into them </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/mongo/bson/<a class="el" href="bsonobj_8h_source.html">bsonobj.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
